## Устные вопросы
~~~
1. Какой самый эффективный способ конкатенации строк?
Наиболее эффективным способом является использование пакета strings и его инструментов(strings.Join, использование strings.Builder)
~~~

~~~
2. Что такое интерфейсы, как они применяются в Go?
Интерфейс - абстракция которая описывает поведение, но не реализует его.
Он определяет и описывает методы, которые должны быть у какого-то другого типа и обязывает реализовать их для соответствия этому интерфейсу.
В Go интерфейс реализуется неявно, то есть нет необходимости указывать, что структуры применяют определенный интерфейс. 
Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс.

Применяются для реализации определенной логики, написания более гибкого кода. Также помогают уменьшить количество шаблонного кода.

К тому же, в go есть пустой интерфейсный тип interface{}.
Он не описывает методы. И поэтому любой объект удовлетворяет пустому интерфейсу.
Таким образом, например, можно передавать либой тип в функцию, принимающую пустой интерфейс.
Пустой интерфейс полезен в случаях, когда необходимо работать с непредсказуемыми или пользовательскими типами.

~~~

~~~
3. Чем отличается RWMutex от Mutex?
Концептуально RWMutex делает тоже что и Mutex: защищает доступ к памяти. 
Однако RWMutex более гибок и дает больше контроля над памятью. 
RWMutex позволяет произвольному числу читателей не нужно ждать друг друга и блокировать доступ к ресурсу, а лишь дождаться пока писатель разблокирует ресурс.
~~~

~~~
4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизированные каналы обладают емкостью. 
Пока канал не заполнится, он не будет блокировать поток в ожидании прочтения.
~~~

~~~
5. Какой размер у структуры struct{}{}?
0 байт
~~~

~~~
6. Есть ли в Go перегрузка методов или операторов?
Нет
~~~

~~~
7. В какой последовательности будут выведены элементы map[int]int?
Пример: 
m[0] = 1
m[1] = 124
m[2] = 281
С 0 элемента до последнего
~~~

~~~
8. В чем разница между make и new?
make возвращает объект, new возвращает указатель 
~~~

~~~
9. Сколько существует способов задать переменную типа slice или map?
3 способа:
- var a[]int
- a := map[int]int{}
- a := make(map[int]int) 
~~~

~~~
10. Что выведет данная программа и почему?

func update(p *int) {
	b := 2
	p = &b
}
func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}

Выведет в обоих случаях 1, потому что функция update работает не с переменной, а с ее указателем.
И получается мы меняем указатель, а не переменную. Чтобы распечаталось 1 и 2, нужно p = &b заменить на *p = b.
~~~

~~~
11. Что выведет данная программа и почему?

func main() {
	wg := sync.WaitGroup{}
	
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

Произойдет дэдлок, так как в функцию мы передаем вэйтгруппу, создается ее копия и работа происходит с ней, хотя задачу вэйтгруппе мы добавляет до вызова функции
Учитывая что анонимная функция находится внутри области видимости вэйтгруппы, можно не передавать ее, а работать напрямую
~~~

~~~
12. Что выведет данная программа и почему?

func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}

Выведет 0, так как внутри if объявляем новую переменную, которая "затеняет" оригинал (shadowed)
~~~

~~~
13. Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
	v[0] = 100  // изменили 0 элемент
	v = append(v, b)    // добавили элемент в v, len(v)=6
}
func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)    // вернулись из функции, a[0] будет измененный, однако len(a) останется равной 5, а так как внутри слайса по ссылке хранится первый элемент массива, а длина не изменилась, добавленный элемент в функции мы не увидим
	fmt.Println(a)
}

Выведет [100 2 3 4 5]
~~~

~~~
14. Что выведет данная программа и почему? 

func main() {
	slice := []string{"a", "a"}
	func(slice []string) {
		slice = append(slice, "a")  // добавляем элемент, cap увеличится до 4, указатель на первый элемент базового массива внутри слайса внутри функции изменится, скопировав значения которые были до, а 4 элемент будет ""
		slice[0] = "b"  // меняем 0 элемент в новом слайсе
		slice[1] = "b"  // меняем 1 элемент в новом слайсе
		fmt.Println(slice)
	}(slice)
	fmt.Println(slice)  // выйдя из функции, в нашем базовом слайсе с cap =  2 хранится указатель на массив из двух символов, изменения не увидим
}

Первая часть выведет [b b a]
После выхода функции выведется старый срез [a a].
~~~